{"title":"Varnish 文档","zzzContent":"近日 Varnish 这款直接针对  squid 的反向代理软件 来势凶猛,众多兄弟也投入使用,至今还未有 缺陷记录,似乎很和谐。于是也测试下下 ...\n\n优点: varnish是一款高性能的开源HTTP加速器，挪威最大的在线报纸 Verdens Gang (http://www.vg.no) 使用3台Varnish代替了原来的12台squid，性能居然比以前更好。\n\nvarnish 的作者Poul-Henning Kamp是FreeBSD的内核开发者之一，他认为现在的计算机比起1975年已经复杂许多。在1975年时，储存媒介只有两种：内存与硬盘。但现在计算机系统的内存除了主存外，还包括了cpu内的L1、L2，甚至有L3快取。硬盘上也有自己的快取装置，因此squid cache自行处理物件替换的架构不可能得知这些情况而做到最佳化，但操作系统可以得知这些情况，所以这部份的工作应该交给操作系统处理，这就是 Varnish cache设计架构。\n\n1.下载源码包编译安装：\n\ncd /usr/local/src && wget http://nchc.dl.sourceforge.net/sourceforge/varnish/varnish-1.1.1.tar.gz\ntar zxvf /usr/local/src/varnish-1.1.1.tar.gz\ncd /usr/local/src/varnish-1.1.1\n./autogen.sh\n./configure --enable-debugging-symbols --enable-developer-warnings --enable-dependency-tracking\n注：如果你的gcc版本是4.2.0或更高的版本，可以加上--enable-extra-warnings编译参数，在出错时，得到附加的警告信息。\n我这里是用源码包安装的，如果你是redhat或centos可以用rpm包来安装（rpm下载位置：http: //sourceforge.net/project/showfiles.php?group_id=155816&package_id=173643&release_id=533569).\n\n2. 建立cache目录：\n\nmkdir -p /cache/varnish/V  && chown -R nobody:nobody /cache\n\n3.编写启动文件:\n\ncd /usr/local/varnish/sbin\nvi start.sh\n内容如下：\n#!/bin/sh\n# file: start.sh\ndate -u\n/usr/local/varnish/sbin/varnishd\n-a 10.0.0.129:80\n-s file,/cache/varnish/V,1024m\n-f /usr/local/varnish/sbin/vg.vcl.default\n-p thread_pool_max=1500\n-p thread_pools=5\n-p listen_depth=512\n-p client_http11=on\n注：-a 是指定后端服务器的ip或hostname，就象squid做revese proxy时的originserver.\n不过这个也可以在vcl里面写。\n-f 是指定所用的vcl的文件。\n-s 指定cache目录的存储类型，文件位置和大小。\n-p 是指定varnish的启动的一些启动参数，可以根据自己的机器配置来优化varnish的性能。\n其他参数已经参数的具体含义可以用varnishd --help 来查看。\n\n4.编写vcl：\n\n我的vcl如下：\n\nbackend default {\n        set backend.host = \"127.0.0.1\";\n        set backend.port = \"http\";\n}\n\n#我用的是一台机器做测试，使用的backend用的是127.0.0.1:80.如果varnish机器和后台的机器分开的。\n写上对应的机器的ip或hostname就可以了。\n\nsub vcl_recv {\n\n        if (req.request != \"GET\" && req.request != \"HEAD\") {\n                pipe;\n        }\n\n        if (req.http.Expect) {\n                pipe;\n        }\n\n        if (req.http.Authenticate || req.http.Cookie) {\n                pass;\n        }\n\n        if (req.request == \"GET\" && req.url ~ \".(gif|jpg|swf|css|js)$\") {\n                lookup;\n        }\n                lookup;\n        }\n\nsub vcl_pipe {\n        pipe;\n        }\n\nsub vcl_pass {\n        pass;\n        }\n\nsub vcl_hash {\n             hash;\n         }\n\nsub vcl_hit {\n        if (!obj.cacheable) {\n                pass;\n        }\n                deliver;\n        }\n\nsub vcl_timeout {\n        discard;\n}\n\nsub vcl_discard {\n        discard;\n}\n\n如果是多个站点在不同的originserver时，可以使用下面配置：\n\nbackend www {\n       set backend.host = \"www.jackbillow.com\";\n       set backend.port = \"80\";\n         }\n\nbackend images {\n      set backend.host = \"images.jackbillow.com\";\n      set backend.port = \"80\";\n         }\n\nsub vcl_recv {\n      if (req.http.host ~ \"^(www.)?jackbillow.com$\") {\n            set req.http.host = \"www.jackbillow.com\";\n            set req.backend = www;\n      } elsif (req.http.host ~ \"^images.jackbillow.com$\") {\n            set req.backend = images;\n      } else {\n            error 404 \"Unknown virtual host\";\n}\n\n5.启动varnish：\n\n/usr/local/varnish/sbin/start.sh\n\nMon Sep  3 03:13:19 UTC 2007\nfile /cache/varnish/V/varnish.tEKXXx (unlinked) size 1073741824 bytes (262144 fs-blocks, 262144 pages)\nUsing old SHMFILE\n\nps waux | grep varnish\nroot     16254  0.0  0.0 11200  708 ? Ss   10:43   0:00 /usr/local/varnish/sbin/varnishd -a 10.0.0.129:80 -s /varnish/V,1024m\n\n-f /usr/local/varnish/sbin/vg.vcl.default -p thread_pool_max 1500 -p thread_pools 5 -p listen_depth 512 -p client_http11 on\nnobody   16255  0.0  0.1 1152552 1808 ?      Sl   10:43   0:00 /usr/local/varnish/sbin/varnishd -a 10.0.0.129:80 -s\n\nfile,/cache/varnish/V,1024m -f /usr/local/varnish/sbin/vg.vcl.default -p thread_pool_max 1500 -p thread_pools 5 -p\n\nlisten_depth 512 -p client_http11 on\n\n看到上面信息说明varnish正确启动，恭喜你，你已经配置成功了。：）\n\n附*********************************************************************************************\nman page意译如下：\n\nVCL语法比较简单，和C类似，if(){}的形式，=和==的区别，!、&&和||等等。但符号没有特别的意思。\nVCL里除了用==、!、&&、||做逻辑判断意外，还可以用~来表示与正则表达式或ACL的匹配。\nVCL其实只是配置，并不是真正的编程语言，没有循环，没有自定义变量。\n\n声明Backend\nbackend 名称 {\nset backend.host = \"域名\";\nset backend.port = \"端口\";\n}\n比如\nbackend www {\nset backend.host = \"www.example.com\";\nset backend.port = \"http\";\n}\n声明的Backend可以用在判断请求针对哪个后端服务器\nif (req.http.host ~ \"^(www.)?example.com$\") {\n{\nset req.backend = www;\n}\n\n声明ACL\nacl 名称 {\n\"IP\";\n\"IP子网\"/反掩码位数;\n! \"IP或IP子网\"/反掩码位数;\n}\n比如\nacl local {\n\"locahost\"; /* myself */\n\"10.0.0.1\"/8; /* and everyone on the local network */\n! \"10.0.0.23\"; /* except for the dialin router */\n}\n判断ACL也很简单\nif (client.ip ~ local) {\npipe;\n}\n\n还可以定义子程序\nsub pipe_if_local {\nif (client.ip ~ local) {\npipe;\n}\n}\n用call来调用\ncall pipe_if_local;\n\n内置的例程\nvcl_recv\n有请求到达后成功接收并分析时被调用，一般以以下几个关键字结束。\nerror code [reason] 返回code给客户端，并放弃处理该请求\npass 进入pass模式，把控制权交给vcl_pass\npipe 进入pipe模式，把控制权交给vcl_pipe\nlookup 在缓存里查找被请求的对象，根据查找结果把控制权交给vcl_hit或vcl_miss\n\nvcl_pipe\n进入pipe模式时被调用。请求被直接发送到backend，后端和客户端之间的后继数据不进行处理，只是简单传递，直到一方关闭连接。一般以以下几个关键字结束。\nerror code [reason]\npipe\n\nvcl_pass\n进入pass模式时被调用。请求被送到后端，后端应答数据送给客户端，但不进入缓存。同一连接的后继请求正常处理。一般以以下几个关键字结束。\nerror code [reason]\npass\n\nvcl_hash\n目前不使用\n\nvcl_hit\n在lookup以后如果在cache中找到请求的内容事调用。一般以以下几个关键字结束。\nerror code [reason]\npass\ndeliver 将找到的内容发送给客户端，把控制权交给vcl_deliver.\n\nvcl_miss\nlookup后但没有找到缓存内容时调用，可以用于判断是否需要从后端服务器取内容。一般以以下几个关键字结束。\nerror code [reason]\npass\nfetch 从后端取得请求的内容，把控制权交给vcl_fetch.\n\n\nvcl_fetch\n从后端取得内容后调用。一般以以下几个关键字结束。\nerror code [reason]\npass\ninsert 将取到的内容插入缓存，然后发送给客户端，把控制权交给vcl_deliver\n\n\nvcl_deliver\n缓存内容发动给客户端前调用。一般以以下几个关键字结束。\nerror code [reason]\ndeliver 内容发送给客户端\n\nvcl_timeout\n在缓存内容到期前调用。一般以以下几个关键字结束。\nfetch 从后端取得该内容\ndiscard 丢弃该内容\n\n\n\nvcl_discard\n由于到期或者空间不足而丢弃缓存内容时调用。一般以以下几个关键字结束。\ndiscard 丢弃\nkeep 继续保留在缓存里\n\n如果这些内置例程没有被定义，则执行缺省动作\n\n\n一些内置的变量\nnow 当前时间，标准时间点（1970？）到现在的秒数\n\nbackend.host 后端的IP或主机名\nbackend.port 后端的服务名或端口\n\n请求到达后有效的变量\nclient.ip 客户端IP\nserver.ip 服务端IP\nreq.request 请求类型，比如GET或者HEAD或者POST\nreq.url 请求的URL\nreq.proto 请求的HTTP版本号\nreq.backend 请求对应的后端\nreq.http.header 对应的HTTP头\n\n往后段的请求时有效的变量\nbereq.request 比如GET或HEAD\nbereq.url URL\nbereq.proto 协议版本\nbereq.http.header HTTP头\n\n从cache或后端取到内容后有效的变量\nobj.proto HTTP协议版本\nobj.status HTTP状态代码\nobj.response HTTP状态信息\nobj.valid 是否有效的HTTP应答\nobj.cacheable 是否可以缓存的内容，也就是说如果HTTP返回是200、203、300、301、302、404、410并且有非0的生存期，则为可缓存\nobj.ttl 生存期，秒\nobj.lastuse 上一次请求到现在间隔秒数\n\n对客户端应答时有效的变量\nresp.proto response的HTTP版本\nresp.status 回给客户端的HTTP状态代码\nresp.response 回给客户端的HTTP状态信息\nresp.http.header HTTP头\n\n\n变量可以通过set来赋值或通过remove来删除（清空）\nsub vcl_recv {\nif (req.http.host ~ \"^(www.)?example.com$\") {\nset req.http.host = \"www.example.com\";\n}\n}\n\nsub vcl_fetch {\nremove obj.http.Set-Cookie;\n}\n\n##########关于varnishd的启动\n进入 /home/admin/varnishd/sbin/,使用 varnishd启动\n启动参数说明\n   -a address:port              # varnishd httpd监听地址及其端口\n    -b address:port              # 后台服务器地址及其端口\n                                 #    -b\n                                 #    -b ':'\n    -d                           # 使用debug模式\n    -f file                      # varnishd 服务器存取规则文件\n    -F                           # Run in foreground\n    -h kind[,hashoptions]        # Hash specification\n                                 #   -h simple_list\n                                 #   -h classic  [default]\n                                 #   -h classic,\n    -n dir                       # varnishd working directory\n    -P file                      # PID file\n    -p param=value               # 服务器参数，用来优化性能\n    -s kind[,storageoptions]     # 缓存内容存放方式\n                                 #   -s malloc\n                                 #   -s file  [default: use /tmp]\n                                 #   -s file,\n                                 #   -s file,,\n    -t                           # Default TTL\n    -T address:port              # telnet管理地址及其端口\n    -V                           # version\n    -w int[,int[,int]]           # 工作线程数\n                                 #   -w\n                                 #   -w min,max\n                #   -w min,max,timeout [default: -w1,1000,120]\n一般使用varnishd -a address:port -b address:port 其他使用默认即可启动\n注意:vcl 中指定 后台服务器的话就不用使用-b 参数了\n4.关于vcl文件的使用说明\nvcl是varnishd的存取策略，即varnishd的配置文件\n#基本格式如下指定后台服务器机器端口\n          backend www {\n             set backend.host = \"www.example.com\";\n             set backend.port = \"http\";\n         }\n   #acl访问控制\n            acl local {\n             \"locahost\";         /* myself */\n             \"10.0.0.1\"/8;       /* and everyone on the local network */\n             ! \"10.0.0.23\";      /* except for the dialin router */\n         }\n   #如果使用虚拟主机，请参照下面代码\n            backend www {\n             set backend.host = \"www.example.com\";\n             set backend.port = \"80\";\n         }\n         backend images {\n             set backend.host = \"images.example.com\";\n             set backend.port = \"80\";\n         }\n         sub vcl_recv {\n             if (req.http.host ~ \"^(www.)?example.com$\") {\n                 set req.backend = www;\n             } elsif (req.http.host ~ \"^images.example.com\") {\n                 set req.backend = images;\n             } else {\n                 error 404 \"Unknown virtual host\";\n             }\n         }\n    #关于cache存在时间设置\n             sub vcl_fetch {\n             if (obj.ttl < 120s) {\n                 set obj.ttl = 120s;\n             }\n         }\n     #cache图片等内容配置\n      sub vcl_recv {\n     if (req.request == \"GET\" && req.url ~ \".(gif|jpg||jpeg|tom|swf|css|js)$\") {\n          lookup;\n     }\n    lookup;\n   }\n##########关于vcl文件的使用说明\nvcl是varnishd的存取策略，即varnishd的配置文件\n#基本格式如下指定后台服务器机器端口\n          backend www {\n             set backend.host = \"www.example.com\";\n             set backend.port = \"http\";\n         }\n   #acl访问控制\n            acl local {\n             \"locahost\";         /* myself */\n             \"10.0.0.1\"/8;       /* and everyone on the local network */\n             ! \"10.0.0.23\";      /* except for the dialin router */\n         }\n   #如果使用虚拟主机，请参照下面代码\n            backend www {\n             set backend.host = \"www.example.com\";\n             set backend.port = \"80\";\n         }\n         backend images {\n             set backend.host = \"images.example.com\";\n             set backend.port = \"80\";\n         }\n         sub vcl_recv {\n             if (req.http.host ~ \"^(www.)?example.com$\") {\n                 set req.backend = www;\n             } elsif (req.http.host ~ \"^images.example.com\") {\n                 set req.backend = images;\n             } else {\n                 error 404 \"Unknown virtual host\";\n             }\n         }\n    #关于cache存在时间设置\n             sub vcl_fetch {\n             if (obj.ttl < 120s) {\n                 set obj.ttl = 120s;\n             }\n         }\n     #cache图片等内容配置\n      sub vcl_recv {\n     if (req.request == \"GET\" && req.url ~ \".(gif|jpg||jpeg|tom|swf|css|js)$\") {\n          lookup;\n     }\n    lookup;\n   }\n########## 关于服务器 param的设置\nparam有以下选项\nuser                 root (0)\ngroup                root (0)\ndefault_ttl          14400 [seconds]\nthread_pools         1 [pools]\nthread_pool_max      12000 [threads]\nthread_pool_min      4000 [threads]\nthread_pool_timeout  10 [seconds]\noverflow_max         100 [%]\nhttp_workspace       8192 [bytes]\nsess_timeout         5 [seconds]\npipe_timeout         60 [seconds]\nsend_timeout         20 [seconds]\nauto_restart         on [bool]\nfetch_chunksize      128 [kilobytes]\nsendfile_threshold   unlimited [bytes]\nvcl_trace            off [bool]\nlisten_address       172.16.189.1:3128\nlisten_depth         1024 [connections]\nsrcaddr_hash         1049 [buckets]\nsrcaddr_ttl          720 [seconds]\nbackend_http11       on [bool]\nclient_http11        on [bool]\nping_interval        3 [seconds]\n大家可以使用-p参数在启动时候进行配置和优化\n例如\n/home/admin/varnish/sbin/varnishd -f /etc/varnish/vcl.conf\n-a 172.16.189.1:3128\n-s malloc\n-p user root -p group root\n-p default_ttl 14400 -p thread_pool_max 8000 -p send_timeout 20\n-p srcaddr_ttl 720 -p backend_http11 on -p client_http11 on\n-w 4000,12000,10 -T 127.0.0.1:8080\n\n########## 关于varnishd的管理\n管理功能的启用需要在启动varnishd的时候 启动 -T参数指定 telnet管理使用的地址和端口\n使用telnet localhost 8080，然后输入help参看相关的管理选项\n或者使用 /home/admin/varnishd/bin/varnishadm -T localhost:8080 cmd进行管理\n使用/home/admin/varnishd/bin/varnishstat 来查看varnishd的运行情况\n\n########## 关于log\n使用home/admin/varnishd/bin/varnishlog  和varnishncsa查看服务器访问log或者让其输出到文件来记录log","postDate":"2009-05-17 12:08:04","postId":"576","type":"post","status":"draft"}